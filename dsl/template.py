cpp_model_template = [
    "#ifndef SYSTEM_MODEL_HPP \n#define SYSTEM_MODEL_HPP \n\n",
    "#include <string> \n#include <vector> \n#include <memory> \n",
    "#include \"task.hpp\"\n#include \"job.hpp\" \n#include \"interval.hpp\" \n",
    "#include \"time.hpp\" \n#include \"processor.hpp\"\n\n",
    "// this file is generated by the DSL parser \n// the system model \n",
    "namespace model {\n",
    "\t// 1. define time model\n",
    # 7 - time model
    "\ttypedef discreteTime time;\n\n",
    "\t// 2. define system events\n",
    "\tevents<time> systemEvents;\n",
    "\tinline void defineEvents() {\n",
    # 11 - events
    "\t\tsystemEvents = events<time>(false, true, true, {});\n",
    "\t}\n\n",
    "\t// 2. define processor model\n",
    "\tstd::vector<processor> processors;\n",
    "\tunsigned int processorCounter = 0;\n\n",
    "\tinline void defineProcessors() {\n",
    # 17 - processors
    "// processors\n",
    "\t}\n\n\t// 3. define task model\n",
    "\tstd::vector<task<time>> tasks;\n\tstd::vector<job<time>> segments;\n",
    "\tunsigned int taskCounter = 0;\n\n",
    "\tinline void defineTasks() {\n",
    # 22 - tasks
    "\t\ttasks.emplace_back(\"t1\", taskCounter++, 10, Interval<time>(1, 2), 10);\n",
    "\t}\n\n",
    "\tinline void defineSegments() {\n",
    # 25 - segments (jobs)
    "\t\tsegments.emplace_back(\"j1\", taskCounter++, 0 , Interval<time>(1, 2), Interval<time>(1, 2), 10);\n",
    "\t}\n\n",
    "}\n\n#endif",]


cpp_scheduler_template = ["#ifndef SCHEDULER_HPP\n#define SCHEDULER_HPP\n\n",
                          "#include <vector>\n#include <algorithm>\n#include <optional>\n#include \"job.hpp\"\n#include \"queue.hpp\"\n\n",
                          "template<class Time>\nclass scheduler {\n",
                          "\ttypedef std::unordered_map<jobID, job<Time>> segmentMap;\n",
                          "\tsegmentMap segmentsByID;\n\n",
                          "public:\n",
                          "\tscheduler() = default;\n\n",
                          "\tscheduler(segmentMap segments) : segmentsByID(segments) { }\n\n",
                          "\tstd::optional<jobID> callScheduler(queue<Time> &readyQueue, const std::unordered_map<std::string, unsigned int> &availableResources, Time currentTime) {\n",
                          "\t\t// if the queue is empty, return an empty optional\n",
                          "\t\tif (readyQueue.empty()) {\n",
                          "\t\t\treturn std::nullopt;\n",
                          "\t\t}\n\n",
                          "\t\t// user defined scheduling algorithm\n",
                          # 14 - scheduling algorithm
                          "\n",
                          "\n\t}\n",
                          "\n\tTime getNextDeadline(std::string taskName, Time currentTime) {\n",
                          "\t\tauto job = segmentsByID.at(getJobID(taskName));\n",
                          "\t\tTime nextDeadline =\n",
                          "\t\tstd::floor(currentTime / job.getTaskPeriod() + 1) * job.getTaskPeriod() - job.getMaximalCost();\n"
                          "\t\treturn nextDeadline;\n\t}",
                          "\n",
                          "\n\tjobID getJobID(std::string taskName) {\n",
                          "\t\tauto it = std::find_if(segmentsByID.begin(), segmentsByID.end(),\n"
                          "\t\t\t[taskName](const std::pair<jobID, job<Time>> &p) {\n"
                          "\t\t\t\t\treturn p.second.getTaskName() == taskName;\n\t\t\t\t});\n",
                          "\t\treturn it->first;\n\t}\n",
                          "};\n\n#endif"
                          ]




# 10 - schedule]
